[{"/Users/pknipp/Desktop/repos/react-frontend-template/src/index.js":"1","/Users/pknipp/Desktop/repos/react-frontend-template/src/App.js":"2","/Users/pknipp/Desktop/repos/traveling-salesman/src/index.js":"3","/Users/pknipp/Desktop/repos/traveling-salesman/src/App.js":"4","/Users/pknipp/Desktop/repos/traveling-salesman/src/Line.js":"5","/Users/pknipp/Desktop/repos/traveling-salesman/src/lookup.js":"6","/Users/pknipp/Desktop/repos/traveling-salesman/src/setTowns.js":"7","/Users/pknipp/Desktop/repos/traveling-salesman/src/Dot.js":"8"},{"size":506,"mtime":1611765216984,"results":"9","hashOfConfig":"10"},{"size":64,"mtime":1611765000156,"results":"11","hashOfConfig":"10"},{"size":506,"mtime":1613786637000,"results":"12","hashOfConfig":"13"},{"size":8083,"mtime":1613859197755,"results":"14","hashOfConfig":"13"},{"size":1274,"mtime":1613838718143,"results":"15","hashOfConfig":"13"},{"size":408,"mtime":1613836866830,"results":"16","hashOfConfig":"13"},{"size":1020,"mtime":1613839728978,"results":"17","hashOfConfig":"13"},{"size":577,"mtime":1613837749104,"results":"18","hashOfConfig":"13"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1s2inzs",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},"m83t6x",{"filePath":"26","messages":"27","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"25"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},"/Users/pknipp/Desktop/repos/react-frontend-template/src/index.js",[],"/Users/pknipp/Desktop/repos/react-frontend-template/src/App.js",[],"/Users/pknipp/Desktop/repos/traveling-salesman/src/index.js",[],["37","38"],"/Users/pknipp/Desktop/repos/traveling-salesman/src/App.js",["39","40","41"],"import React, { useEffect, useState } from 'react';\nimport Line from './Line';\nimport Dot from './Dot';\nimport setTowns from './setTowns';\nimport lookup from './lookup';\n\nconst App = () => {\n  const [n, setN] = useState(0);\n  const [xyzs, setXyzs] = useState([]);\n  const [interTownDistances, setInterTownDistances] = useState([[0]]);\n  const [facPerm, setFacPerm] = useState(1);\n  const [distanceMin, setDistanceMin] = useState([Infinity]);\n  const [itin, setItin] = useState([[]]);\n  const [iterPermI, setIterPermI] = useState(-1);\n  const [nextIterPermI, setNextIterPermI] = useState(0);\n  const [done, setDone] = useState(false);\n  const [start, setStart] = useState(false);\n  const [memo, setMemo] = useState([]);\n  const d = 50;\n  const nx = 1500;\n  const nyz = 600;\n  const zmin = 10;\n  const ue0 = () => {\n    if (!n) return;\n    let newFacPerm = 1;\n    for(let i = 1; i <= n; i ++) newFacPerm *= i;\n    setFacPerm(newFacPerm);\n    const newXyzs = setTowns(n, nx, nyz, zmin);\n    setInterTownDistances(lookup(newXyzs));\n    setXyzs(newXyzs);\n    setIterPermI(0);\n    setNextIterPermI(1);\n    setItin([[]]);\n    setDistanceMin([Infinity]);\n    setDone(false);\n    setStart(false);\n    setMemo([]);\n  }\n  useEffect(ue0, [n]);\n  const ue1 = () => {\n    if (!n || !start) return;\n    let newDistanceMin = [...distanceMin];\n    let newMemo = [...memo];\n    for(let iterPerm = iterPermI; iterPerm < facPerm; iterPerm ++){\n      // salesman starts at origin, which (xyzs[n][0], xyzs[n][1]) is defined to be.\n      let indexLast = n;\n      let distanceTot = 0;\n      let iter = iterPerm;\n      let rangePerm = new Array(n).fill(0).map((blah, i) => i);\n      let range = [...rangePerm];\n      let fac = facPerm;\n      let newItin = [];\n      let areSame = true;\n      for(let place = n - 1; place >= 0; place --){\n        let i = n - 1 - place;\n        fac /= (place + 1);\n        let digit = Math.floor(iter/fac);\n        let index = range.splice(digit,1)[0];\n        newItin.push(index);\n        areSame = areSame && memo[i] && memo[i][0] === index;\n        if (!areSame) memo[i] = [index, distanceTot + interTownDistances[indexLast][index]];\n        distanceTot = memo[i][1];\n        // let key = newItin.join('-');\n        // if (!(key in newMemo)) newMemo[key] = distanceTot + interTownDistances[indexLast][index];\n        // distanceTot = newMemo[key];\n        iter -= digit * fac;\n        indexLast = index;\n      }\n      // salesman ends at the origin, which (xys[n][0], xys[n][1]) is defined to be.\n      distanceTot += interTownDistances[indexLast][n];\n      newItin.unshift(n);\n      newItin.push(n);\n      console.log(newItin.join(''), distanceTot)\n      if(distanceTot < newDistanceMin[0]) {\n        setItin([newItin, ...itin]);\n        setDistanceMin([distanceTot, ...newDistanceMin]);\n        setNextIterPermI(iterPerm + 1);\n        setMemo(newMemo);\n        break;\n      }\n      if (iterPerm === facPerm - 1) setDone(true);\n    }\n  }\n  useEffect(ue1, [iterPermI, interTownDistances, distanceMin, facPerm, itin, start]);\n  const ue2 = () => {\n    if (!n || !start) return;\n    setIterPermI(nextIterPermI);\n  }\n  useEffect(ue2, [distanceMin, n, nextIterPermI, start])\n  const ue3 = () => {\n    console.log(\"done!\");\n  }\n  useEffect(ue3, [done]);\n  return (\n    <>\n      <div className=\"top\">\n        <p align=\"center\"><h1>3-dimensional \"Traveling Salesman Problem\"</h1></p>\n        <p>\n          In this 3-d version of the classical NP-hard computing problem, a galactic salesman plans a route which enables him/her to leave home and visit all <i>N</i> planets in that portion of the galaxy, while traveling the shortest possible distance.  The time complexity for my brute-force algorithm is \"factorial\" [<i>O</i>(<i>N</i>!)], which means that the planning time required for 10 planets will be 10 times longer than that for 9 planets, and the time required for 11 planets will be 11 times longer than that for 10, etc.  The algorithm is seemingly instantaneous for <i>N</i> &lt; 9 and usually stalls for <i>N</i> &gt; 11.\n        </p>\n      </div>\n      <div className=\"container\">\n        <div className=\"left\">\n          <div>Select the<br/> number<br/> of planets:</div>\n          <input type=\"number\" min=\"0\" step=\"1\" value={n}\n            onChange={e => setN(Number(e.target.value))}\n          /><br/>\n          {!n ? null :\n            <>\n            {done ? <>Finished!<br/><br/></> : null}\n            <>\n              <button onClick={() => {\n                let newStart = !start;\n                setStart(newStart);\n              }}>\n                {start ? \"Cancel\" : \"Start\"}\n              </button>\n              {!start ? null :\n                <>\n                  <div>Number<br/>of routes<br/> checked:</div>\n                  <div>{(iterPermI + 1).toLocaleString()}</div><br/>\n                  <div>Percentage<br/> completed:</div>\n                  <div>{Math.round(100 * iterPermI/facPerm)}</div><br/>\n                  Successive<br/>\n                  minimum<br/>\n                  distances<br/>\n                  found:<br/><br/>\n                  {[...distanceMin].reverse().filter((distanceMin, index) => index).map(distanceMin=> {\n                    return <div>{distanceMin.toFixed(1)}</div>\n                  })}\n                </>\n              }\n            </>\n            </>\n          }\n        </div>\n\n        <div className=\"right\">\n          {/* {itin.map((itin, index) => {\n            return itin.map((townIndex, itinIndex) => {\n              return (itinIndex === itin.length - 1) ? null :\n                <Line key={itinIndex} index={index}\n                  xi={xys[townIndex][0]} xf={xys[itin[itinIndex + 1]][0]}\n                  yi={xys[townIndex][1]} yf={xys[itin[itinIndex + 1]][1]}\n                />\n            })\n          })} */}\n          {xyzs.map((xyz, index) => (\n            <>\n            <Dot key={index} x={xyz[0]} y={xyz[1]} z={xyz[2]} index={index} d={d} d={d} nx={nx} nyz={nyz} />\n            <Dot key={\"dashed\" + index} x={xyz[0]} y={xyz[1]} z={xyz[2]} index={index} d={d} d={d} nx={nx} nyz={nyz} dashed={true} />\n            </>\n          ))}\n          {!start ? null : itin[0].map((townIndex, itinIndex) => {\n            return (itinIndex === itin[0].length - 1) ? null :\n                <>\n                <Line key2={itinIndex} key={'bot' + townIndex + ' ' + itin[0][itinIndex + 1]}\n                  done={done} d={d} nx={nx} nyz={nyz} zmin ={zmin}\n                  xi={xyzs[townIndex][0]} xf={xyzs[itin[0][itinIndex + 1]][0]}\n                  yi={xyzs[townIndex][1]} yf={xyzs[itin[0][itinIndex + 1]][1]}\n                  zi={xyzs[townIndex][2]} zf={xyzs[itin[0][itinIndex + 1]][2]}\n                />\n                <Line key2={itinIndex} key={'top' + townIndex + ' ' + itin[0][itinIndex + 1]}\n                  done={done} d={d} which={true} nx={nx} nyz={nyz}\n                  xi={xyzs[townIndex][0]} xf={xyzs[itin[0][itinIndex + 1]][0]}\n                  yi={xyzs[townIndex][1]} yf={xyzs[itin[0][itinIndex + 1]][1]}\n                  zi={xyzs[townIndex][2]} zf={xyzs[itin[0][itinIndex + 1]][2]}\n                />\n                <Line key2={itinIndex} key={'dashedbot' + townIndex + ' ' + itin[0][itinIndex + 1]}\n                  done={done} d={d} nx={nx} nyz={nyz} zmin ={zmin} dashed={true}\n                  xi={xyzs[townIndex][0]} xf={xyzs[itin[0][itinIndex + 1]][0]}\n                  yi={xyzs[townIndex][1]} yf={xyzs[itin[0][itinIndex + 1]][1]}\n                  zi={xyzs[townIndex][2]} zf={xyzs[itin[0][itinIndex + 1]][2]}\n                />\n                <Line key2={itinIndex} key={'dashedtop' + townIndex + ' ' + itin[0][itinIndex + 1]}\n                  done={done} d={d} which={true} nx={nx} nyz={nyz} dashed={true}\n                  xi={xyzs[townIndex][0]} xf={xyzs[itin[0][itinIndex + 1]][0]}\n                  yi={xyzs[townIndex][1]} yf={xyzs[itin[0][itinIndex + 1]][1]}\n                  zi={xyzs[townIndex][2]} zf={xyzs[itin[0][itinIndex + 1]][2]}\n                />\n                </>\n          })}\n        </div>\n      </div>\n    </>\n  );\n};\nexport default App;\n","/Users/pknipp/Desktop/repos/traveling-salesman/src/Line.js",[],"/Users/pknipp/Desktop/repos/traveling-salesman/src/lookup.js",[],"/Users/pknipp/Desktop/repos/traveling-salesman/src/setTowns.js",[],"/Users/pknipp/Desktop/repos/traveling-salesman/src/Dot.js",[],{"ruleId":"42","replacedBy":"43"},{"ruleId":"44","replacedBy":"45"},{"ruleId":"46","severity":1,"message":"47","line":84,"column":18,"nodeType":"48","endLine":84,"endColumn":84,"suggestions":"49"},{"ruleId":"50","severity":1,"message":"51","line":150,"column":83,"nodeType":"52","endLine":150,"endColumn":88},{"ruleId":"50","severity":1,"message":"51","line":151,"column":94,"nodeType":"52","endLine":151,"endColumn":99},"no-native-reassign",["53"],"no-negated-in-lhs",["54"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'memo' and 'n'. Either include them or remove the dependency array.","ArrayExpression",["55"],"react/jsx-no-duplicate-props","No duplicate props allowed","JSXAttribute","no-global-assign","no-unsafe-negation",{"desc":"56","fix":"57"},"Update the dependencies array to be: [iterPermI, interTownDistances, distanceMin, facPerm, itin, start, n, memo]",{"range":"58","text":"59"},[2966,3032],"[iterPermI, interTownDistances, distanceMin, facPerm, itin, start, n, memo]"]