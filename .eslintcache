[{"/Users/pknipp/Desktop/repos/react-frontend-template/src/index.js":"1","/Users/pknipp/Desktop/repos/react-frontend-template/src/App.js":"2","/Users/pknipp/Desktop/repos/traveling-salesperson/src/index.js":"3","/Users/pknipp/Desktop/repos/traveling-salesperson/src/App.js":"4","/Users/pknipp/Desktop/repos/traveling-salesperson/src/Line.js":"5","/Users/pknipp/Desktop/repos/traveling-salesperson/src/Dot.js":"6","/Users/pknipp/Desktop/repos/traveling-salesperson/src/setTowns.js":"7","/Users/pknipp/Desktop/repos/traveling-salesperson/src/lookup.js":"8","/Users/pknipp/Desktop/repos/traveling-salesperson/src/ToggleInfo.js":"9"},{"size":506,"mtime":1611765216984,"results":"10","hashOfConfig":"11"},{"size":64,"mtime":1611765000156,"results":"12","hashOfConfig":"11"},{"size":506,"mtime":1613786637000,"results":"13","hashOfConfig":"14"},{"size":15765,"mtime":1614457432384,"results":"15","hashOfConfig":"14"},{"size":1475,"mtime":1614100267140,"results":"16","hashOfConfig":"14"},{"size":861,"mtime":1614098747190,"results":"17","hashOfConfig":"14"},{"size":1284,"mtime":1614089713295,"results":"18","hashOfConfig":"14"},{"size":408,"mtime":1613836866830,"results":"19","hashOfConfig":"14"},{"size":433,"mtime":1614000580388,"results":"20","hashOfConfig":"14"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1s2inzs",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},"1osn773",{"filePath":"28","messages":"29","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"27"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},"/Users/pknipp/Desktop/repos/react-frontend-template/src/index.js",[],"/Users/pknipp/Desktop/repos/react-frontend-template/src/App.js",[],"/Users/pknipp/Desktop/repos/traveling-salesperson/src/index.js",[],["42","43"],"/Users/pknipp/Desktop/repos/traveling-salesperson/src/App.js",["44","45"],"import React, { useEffect, useState } from 'react';\nimport Line from './Line';\nimport Dot from './Dot';\nimport ToggleInfo from './ToggleInfo';\nimport info from \"./info.png\";\nimport cancel from \"./cancel.jpeg\";\nimport setTowns from './setTowns';\nimport lookup from './lookup';\n\nconst App = () => {\n  // px apparent diameter of most-distant planet\n  const d = 20;\n  // horizontal number of px of viewing area\n  const nx = 1500;\n  // number of px both vertically and perpendicular to screen\n  const nyz = 600;\n  // z-value number of px for closest planet\n  const zMin = 20;\n  // dim = 2 or 3\n  const [dim, setDim] = useState(0);\n  // number of towns/planets (not including \"home\")\n  const [n, setN] = useState(0);\n  // = 1 (for randomly chosen towns) or 2 (for towns specified by clicking)\n  const [choose, setChoose] = useState(0);\n  // coordinates of the towns, \"home\" is the last one\n  // centroid of a pyramid is 3/4 of the way from the apex to the base\n  const [xyzs, setXyzs] = useState([[nx / 2, nyz / 2, nyz]]);\n  // NxN symmetric matrix w/0 on diagonals contains the distances, for lookup\n  const [interTownDistances, setInterTownDistances] = useState([[0]]);\n  // N!\n  const [facPerm, setFacPerm] = useState(1);\n  // value of the evolving optimal distance\n  const [distanceMin, setDistanceMin] = useState([Infinity]);\n  // itinerary of the evolving optimal path\n  const [itin, setItin] = useState([]);\n  // evolving value of the initial value of the (base-10) iteration for the permutation\n  // this updates every time the loop is broken because a local optimal path is found\n  const [iterPermI, setIterPermI] = useState(-1);\n  // 1 + previous value (perhaps not needed?)\n  const [nextIterPermI, setNextIterPermI] = useState(0);\n  const [done, setDone] = useState(false);\n  // false until the completion of the for-loop\n  const [start, setStart] = useState(false);\n  // used to memoize values of preliminary parts of path\n  const [memo, setMemo] = useState([]);\n  // state of mouseClick\n  const [down, setDown] = useState(false);\n  // mouse-detected (apparent) coordinates for points which are clicked\n  const [X, setX] = useState(null);\n  const [Y, setY] = useState(null);\n  // evolving z-coord when controlled by click duration\n  const [z, setZ] = useState(nyz);\n  // info for various controls\n  const [showInfo, setShowInfo] = useState({});\n\n  const ue0 = () => {\n    if (!n) return;\n    let newFacPerm = 1;\n    for(let i = 1; i <= n; i ++) newFacPerm *= i;\n    setFacPerm(newFacPerm);\n    setIterPermI(0);\n    setNextIterPermI(1);\n    setItin([]);\n    setDistanceMin([Infinity]);\n    setDone(false);\n    setStart(false);\n    setMemo([]);\n  }\n  useEffect(ue0, [n, dim]);\n\n  const ue1 = () => {\n    if (!n || !start) return;\n    let newMemo = [...memo];\n    // loop over all permutations (ie, all possible itineraries)\n    for(let iterPerm = iterPermI; iterPerm < facPerm; iterPerm ++){\n      // salesperson starts at origin, which (xyzs[n][0], xyzs[n][1]) is defined to be.\n      let indexLast = n;\n      let distanceTot = 0;\n      let iter = iterPerm;\n      // range = [0, 1, 2, ...], which is used to generated permutations\n      let range = new Array(n).fill(0).map((blah, i) => i);\n      let dIter = Math.round(facPerm/1000);\n      let fac = facPerm;\n      let newItin = [];\n      // flag used to determine whether or not memo can be used\n      let areSame = true;\n      // determination of digits of factorial-base representation of iterPerm\n      for(let place = n - 1; place >= 0; place --){\n        let i = n - 1 - place;\n        fac /= (place + 1);\n        let digit = Math.floor(iter/fac);\n        let index = range.splice(digit,1)[0];\n        newItin.push(index);\n        areSame = areSame && memo[i] && memo[i][0] === index;\n        // ... if existing element in memo cannot be used, then reassign it\n        if (!areSame) memo[i] = [index, distanceTot + interTownDistances[indexLast][index]];\n        distanceTot = memo[i][1];\n        // The following memo has excessive space complexity [O(n!)].\n        // Accordingly, I chose not to use it.\n        // let key = newItin.join('-');\n        // if (!(key in newMemo)) newMemo[key] = distanceTot + interTownDistances[indexLast][index];\n        // distanceTot = newMemo[key];\n        iter -= digit * fac;\n        indexLast = index;\n      }\n      // salesperson ends at the origin, which (xys[n][0], xys[n][1]) is defined to be.\n      distanceTot += interTownDistances[indexLast][n];\n      newItin.unshift(n);\n      newItin.push(n);\n      if (distanceTot < distanceMin[0]) {\n        // Replace the existing itinerary with the current one\n        setItin(newItin);\n        setDistanceMin([distanceTot, ...distanceMin]);\n        setNextIterPermI(iterPerm + 1);\n        setMemo(newMemo);\n        break;\n      }\n      // Break in order to display the next 0.1% of progress.\n      // Before both loops, dIter was defined to be Math.round(facPerm/1000)\n      if (!(iterPerm % dIter)) {\n        setNextIterPermI(iterPerm + 1);\n        break;\n      }\n      // The loop is done.\n      if (iterPerm === facPerm - 1) {\n        setDone(true);\n        setNextIterPermI(iterPerm);\n      }\n    }\n  }\n  useEffect(ue1, [iterPermI, interTownDistances, distanceMin, facPerm, itin, start]);\n\n  // I'm not sure if this useEffect could be eliminated.\n  const ue2 = () => {\n    if (!n || !start) return;\n    setIterPermI(nextIterPermI);\n  }\n  useEffect(ue2, [distanceMin, n, nextIterPermI, start])\n\n  const handleDown = e => {\n    // disable event listener when enough points have been clicked\n    if (xyzs.length === n + 1) return;\n    setDown(true);\n    // following two setters are for apparent - not actual - lateral position\n    let newX = e.nativeEvent.offsetX;\n    let newY = e.nativeEvent.offsetY;\n    setX(newX);\n    setY(newY);\n    // The point should start at the most distant location, if this is 3-d.\n    setZ(nyz);\n    // let newXyzs = [[newX, newY, nyz], ...xyzs];\n    // This will render the new planet during the mouse depression.\n    setXyzs([[newX, newY, nyz], ...xyzs]);\n  }\n\n  const handleUp = e => {\n    setDown(false);\n    setInterTownDistances(lookup(xyzs));\n  }\n\n  useEffect(() => {\n    let interval = null;\n    if (down) {\n      let x = nx / 2 + z * (X - nx / 2) / nyz;\n      let y = nyz / 2 + z * (Y - nyz / 2) / nyz;\n      setXyzs([[x, y, z], ...xyzs.slice(1)]);\n      // the z-coordinate will decrease by 1 px w/each passing ms.\n      interval = setInterval(() => {\n        setZ(z => Math.max(z - (dim === 1 ? 0 : 1), zMin));\n      }, 1);\n    } else if (!down && z !== nyz) {\n      clearInterval(interval);\n    }\n    return () => clearInterval(interval);\n  }, [down, z, X, Y, dim]);\n\n  const handleToggle = e => {\n    let name = e.currentTarget.name;\n    let newShowInfo = {...showInfo};\n    newShowInfo[name] = !showInfo[name];\n    setShowInfo(newShowInfo);\n  }\n\n  let text = {\n    dim:`You have two choices for the region's dimensionality. A 2-dimensional region will correspond to the box below: ${nx}px x ${nyz}px.  The presence of a third dimension (if chosen) will be simulated by the obvious fact that closer planets appear larger. The 3-dimensional region will be the frustum of a pyramid whose base has the dimensions of the window below and whose height (perpendicular to the screen) equals ${nyz}px minus ${zMin}px, the latter length corresponding to the closest allowable distance to the viewer. My choice of a pyramidal shape ensures that no planets will be outside of your peripheral vision, even if close to you.  My use of a frustum ensures that the apparent size of no planet will be inconveniently large. One thing to notice: in 2-d the shortest path can have no apparent \"crossovers\", whereas this may not be the case in 3-d.`,\n    n:\"The time complexity for my brute-force algorithm is 'factorial' [O(N!)], which means that the calculation-time required for N = 10 will be 10 times longer than that for N = 9 planets, and the time required for N = 11 will be 11 times longer than that for 10, etc.  On my computer the present algorithm is seemingly instantaneous for N < 9 but is much slower for larger N. Note that N does NOT include the salesperson's home, where the journey starts and ends.\",\n    choose:`${dim === 1 ? \"This'll consist simply of a sequence of point-and-clicks at different locations on the screen.  Regardless of the pattern of your towns, you should probably create them in a random order, because the first path chosen by my algorithm is the one that follows the sequence with which you created the towns.\" : \"If you choose 'random', each planet will be placed randomly within this pyramical region.  If you choose 'click', each planet's lateral position corresponds simply to your click's position, whereas the planet's z-coordinate is controlled by your click's duration as follows: a brief click will create a planet far from the viewer whereas a long click will create one nearby.\"}`,\n  }\n\n  return (\n    <>\n      <div className=\"top\">\n        <p align=\"center\"><h1>Traveling Salesperson Problem</h1></p>\n        <p>\n          In this classical NP-hard computing problem, a salesperson plans a route which enables him/her to leave home and visit all <i>N</i> points in that region while traveling the shortest possible distance.  You may implement this planning algorithm either in two dimensions (the traditional problem) or in three (as for a galactic salesperson who visits different planets).\n          Each control below has a place where you can click '<img src={info} alt=\"Show information.\" />/<img src={cancel} alt=\"Hide information.\" />' in order to toggle the display of information about the particular control.\n        </p>\n        <table>\n          <thead><tr></tr></thead>\n          <tbody>\n            <tr>\n              <td>\n                <select value={dim} onChange={e => {\n                  let newDim = Number(e.target.value);\n                  setN(0);\n                  setChoose(0);\n                  setDim(newDim);\n                  // This overrides default value of z = nyz.\n                  setXyzs([[nx / 2, nyz / 2, nyz * (newDim === 2 ? 0.75 : 1)]]);\n                }}>\n                  {['2d or 3d?', '2-dim', '3-dim'].map((option, i) => <option key={i} value={i}>{option} </option>)}\n                </select>&nbsp;\n              </td>\n              <td style={{whiteSpace: \"nowrap\"}}>\n                Select the dimensionality of the salesperson's region.\n              </td>\n              <td>\n                &nbsp;<ToggleInfo onClick={handleToggle} name=\"dim\" toggle={showInfo.dim} />\n              </td>\n              <td>\n                &nbsp;<i>{showInfo.dim ? text.dim : null}</i>\n              </td>\n            </tr>\n            {!dim ? null : <tr>\n              <td>\n                <input type=\"number\" min=\"0\" step=\"1\" value={n}\n                  onChange={e => {\n                    setChoose(0);\n                    setN(Number(e.target.value));\n                  }}\n                />&nbsp;\n              </td>\n              <td style={{whiteSpace: \"nowrap\"}}>\n                Specify the number of points along the salesperson's route.\n              </td>\n              <td>\n                &nbsp;<ToggleInfo onClick={handleToggle} name=\"n\" toggle={showInfo.n} />\n              </td>\n              <td>\n                &nbsp;<i>{showInfo.n ? text.n : null}</i>\n              </td>\n            </tr>}\n            {!n ? null : <tr>\n              <td>\n                <select value={choose} onChange={e => {\n                  let newChoose = Number(e.target.value);\n                  setChoose(newChoose);\n                  if (newChoose === 1) {\n                    let newXyzs = [...setTowns(n, nx, nyz, zMin, dim), ...xyzs];\n                    setXyzs(newXyzs);\n                    setInterTownDistances(lookup(newXyzs));\n                  }\n                }}>\n                  {['rand or click?', 'random', 'click'].map((option, i) => <option key={i} value={i}>{option} </option>)}\n                </select>&nbsp;\n              </td>\n              <td style={{whiteSpace: \"nowrap\"}}>\n                Specify if points should be chosen randomly or by clicking.\n              </td>\n              <td>\n                &nbsp;<ToggleInfo onClick={handleToggle} name=\"choose\" toggle={showInfo.choose} />\n              </td>\n              <td>\n                &nbsp;<i>{showInfo.choose ? text.choose : null}</i>\n              </td>\n            </tr>}\n          </tbody>\n        </table>\n\n      </div>\n\n      <div className=\"container\">\n\n        <div className=\"left\">\n          {done ? <><br/><div style={{color: \"blue\"}}>FINISHED!</div><br/></> : null}\n          {!(n && xyzs.length === n + 1 && !down) ? null :\n            <>\n              {start ? null : <button onClick={() => setStart(true)}>Start</button>}\n              {!start ? null :\n                <>\n                  <div>Number<br/>of routes<br/> checked:</div>\n                  <div>{(nextIterPermI + 1).toLocaleString()}</div><br/>\n                  <div>Percentage<br/> completed:</div>\n                  <div>{Math.round(1000 * nextIterPermI/facPerm)/10}</div><br/>\n                  Successive<br/>\n                  minimum<br/>\n                  distances<br/>\n                  found:<br/><br/>\n                  {[...distanceMin].reverse().filter((distanceMin, index) => index).map(distanceMin=> {\n                    return <div>{distanceMin.toFixed(1)}</div>\n                  })}\n                </>\n              }\n            </>\n          }\n        </div>\n\n        <div className=\"right\"\n          style={{height:`${nyz}px`, width: `${nx}px`}}\n          // onClick={handleClick}\n          onMouseDown={handleDown}\n          onMouseUp={handleUp}\n        >\n          {xyzs.map((xyz, index) => (\n            <>\n              <Dot key={index} x={xyz[0]} y={xyz[1]} z={xyz[2]} d={d} nx={nx} nyz={nyz} />\n              <Dot key={\"dashed\" + index} x={xyz[0]} y={xyz[1]} z={xyz[2]} d={d} nx={nx} nyz={nyz} dashed={true}/>\n            </>\n          ))}\n          {!start ? null : itin.map((townIndex, itinIndex) => {\n            return (itinIndex === itin.length - 1) ? null :\n              <>\n                <Line key={'bot' + townIndex + ' ' + itin[itinIndex + 1]}\n                  d={d} nx={nx} nyz={nyz}\n                  xi={xyzs[townIndex][0]} xf={xyzs[itin[itinIndex + 1]][0]}\n                  yi={xyzs[townIndex][1]} yf={xyzs[itin[itinIndex + 1]][1]}\n                  zi={xyzs[townIndex][2]} zf={xyzs[itin[itinIndex + 1]][2]}\n                />\n                <Line key={'top' + townIndex + ' ' + itin[0][itinIndex + 1]}\n                  d={d} which={true} nx={nx} nyz={nyz}\n                  xi={xyzs[townIndex][0]} xf={xyzs[itin[itinIndex + 1]][0]}\n                  yi={xyzs[townIndex][1]} yf={xyzs[itin[itinIndex + 1]][1]}\n                  zi={xyzs[townIndex][2]} zf={xyzs[itin[itinIndex + 1]][2]}\n                />\n                <Line key={'dashedbot' + townIndex + ' ' + itin[0][itinIndex + 1]}\n                  d={d} nx={nx} nyz={nyz} dashed={true}\n                  xi={xyzs[townIndex][0]} xf={xyzs[itin[itinIndex + 1]][0]}\n                  yi={xyzs[townIndex][1]} yf={xyzs[itin[itinIndex + 1]][1]}\n                  zi={xyzs[townIndex][2]} zf={xyzs[itin[itinIndex + 1]][2]}\n                />\n                <Line key={'dashedtop' + townIndex + ' ' + itin[0][itinIndex + 1]}\n                  d={d} which={true} nx={nx} nyz={nyz} dashed={true}\n                  xi={xyzs[townIndex][0]} xf={xyzs[itin[itinIndex + 1]][0]}\n                  yi={xyzs[townIndex][1]} yf={xyzs[itin[itinIndex + 1]][1]}\n                  zi={xyzs[townIndex][2]} zf={xyzs[itin[itinIndex + 1]][2]}\n                />\n              </>\n          })}\n        </div>\n      </div>\n    </>\n  );\n};\nexport default App;\n","/Users/pknipp/Desktop/repos/traveling-salesperson/src/Line.js",[],"/Users/pknipp/Desktop/repos/traveling-salesperson/src/Dot.js",[],"/Users/pknipp/Desktop/repos/traveling-salesperson/src/setTowns.js",[],"/Users/pknipp/Desktop/repos/traveling-salesperson/src/lookup.js",[],["46","47"],"/Users/pknipp/Desktop/repos/traveling-salesperson/src/ToggleInfo.js",[],{"ruleId":"48","replacedBy":"49"},{"ruleId":"50","replacedBy":"51"},{"ruleId":"52","severity":1,"message":"53","line":131,"column":18,"nodeType":"54","endLine":131,"endColumn":84,"suggestions":"55"},{"ruleId":"52","severity":1,"message":"56","line":175,"column":6,"nodeType":"54","endLine":175,"endColumn":26,"suggestions":"57"},{"ruleId":"48","replacedBy":"58"},{"ruleId":"50","replacedBy":"59"},"no-native-reassign",["60"],"no-negated-in-lhs",["61"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'memo' and 'n'. Either include them or remove the dependency array.","ArrayExpression",["62"],"React Hook useEffect has a missing dependency: 'xyzs'. Either include it or remove the dependency array. You can also do a functional update 'setXyzs(x => ...)' if you only need 'xyzs' in the 'setXyzs' call.",["63"],["60"],["61"],"no-global-assign","no-unsafe-negation",{"desc":"64","fix":"65"},{"desc":"66","fix":"67"},"Update the dependencies array to be: [iterPermI, interTownDistances, distanceMin, facPerm, itin, start, n, memo]",{"range":"68","text":"69"},"Update the dependencies array to be: [down, z, X, Y, dim, xyzs]",{"range":"70","text":"71"},[5172,5238],"[iterPermI, interTownDistances, distanceMin, facPerm, itin, start, n, memo]",[6636,6656],"[down, z, X, Y, dim, xyzs]"]